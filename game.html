<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pipe Puzzle Game</title>
  <style>
    body {
      font-family: sans-serif;
      background: #55c1ff;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 360px;
      margin-bottom: 10px;
      font-size: 1.2rem;
      color: #333;
    }

    .stars {
      font-size: 1.5rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(6, 60px);
      grid-template-rows: repeat(6, 60px);
      gap: 2px;
      background: #159A48;
      padding: 5px;
      border: 4px solid #159A48;
      border-radius: 2%;
    }

    .tile {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f0f0f0;
      border-radius: 1%;
      user-select: none;
      position: relative;
    }

    .tile img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
      background-color: #4FCB53;
    }

    .tile.source,
    .tile.house,
    .tile.rock {
      background-color: #4FCB53;
    }

    .footer {
      margin-top: 20px;
      font-size: 0.9rem;
      color: #444;
    }
  </style>
</head>
<body>

  <div class="hud">
    <div>Level 1</div>
    <div>‚è±Ô∏è <span id="timer">60</span>s</div>
    <div class="stars" id="stars">‚≠ê‚≠ê‚≠ê</div>
  </div>

  <div class="grid" id="grid"></div>

  <div class="footer">Click pipes to rotate. Connect üö∞ to üè† before time runs out!</div>

  <script>
    const SIZE = 6;
    const grid = document.getElementById('grid');
    const timerEl = document.getElementById('timer');
    const starsEl = document.getElementById('stars');
    let tiles = [];
    let timer = 60;
    let interval;
    let gameWon = false;

    const layout = [
      'rock', 'corner', 'tcross', 'pipe', 'pipe', 'house',
      'corner', 'tcross', 'pipe', 'corner', 'rock', 'rock',
      'pipe', 'rock', 'corner', 'rock', 'rock', 'rock',
      'pipe', 'pipe', 'tcross', 'pipe', 'corner', 'rock',
      'corner', 'tcross', 'source', 'pipe', 'pipe', 'rock',
      'rock', 'corner', 'pipe', 'pipe', 'corner', 'rock'
    ];

    const directions = {
      up: [0, -1],
      right: [1, 0],
      down: [0, 1],
      left: [-1, 0]
    };

    function getImageSrc(type, rotatable) {
      const base = rotatable ? '-yellow' : '';
      switch (type) {
        case 'pipe': return `img/straight${base}.png`;
        case 'corner': return `img/corner${base}.png`;
        case 'tcross': return `img/3-cross${base}.png`;
        case 'cross': return `img/4-cross${base}.png`;
        default: return null;
      }
    }

    function getConnections(type, rotation) {
      const deg = parseInt(rotation || 0) % 360;
      switch (type) {
        case 'pipe':
          return deg % 180 === 0 ? ['up', 'down'] : ['left', 'right'];
        case 'corner':
          return {
            0: ['down', 'right'],
            90: ['left', 'down'],
            180: ['up', 'left'],
            270: ['up', 'right']
          }[deg];
        case 'tcross':
          return {
            0: ['down', 'up', 'right'],
            90: ['left', 'right', 'down'],
            180: ['up', 'down', 'left'],
            270: ['right', 'left', 'up']
          }[deg];
        case 'cross':
          return ['up', 'right', 'down', 'left'];
        case 'source':
        case 'house':
          return ['left', 'right', 'up', 'down'];
        default:
          return [];
      }
    }

    function posToIndex(x, y) {
      return y * SIZE + x;
    }

    function isValidCoord(x, y) {
      return x >= 0 && x < SIZE && y >= 0 && y < SIZE;
    }

    function getOpposite(dir) {
      return { up: 'down', down: 'up', left: 'right', right: 'left' }[dir];
    }

    function rotateTile(tile) {
      if (!tile.classList.contains('rotatable')) return;
      let current = parseInt(tile.dataset.rotation || 0);
      current = (current + 90) % 360;
      tile.dataset.rotation = current;
      tile.style.transform = `rotate(${current}deg)`;
    }

    function buildGrid() {
      grid.innerHTML = '';
      tiles = [];

      layout.forEach((type, i) => {
        const tile = document.createElement('div');
        tile.className = `tile ${type}`;
        tile.dataset.type = type;
        tile.dataset.rotation = 0;

        const isRotatable = ['pipe', 'corner', 'tcross', 'cross'].includes(type);
        if (isRotatable) tile.classList.add('rotatable');

        const imgSrc = getImageSrc(type, isRotatable);
        if (imgSrc) {
          const img = document.createElement('img');
          img.src = imgSrc;
          tile.appendChild(img);
        } else if (['source', 'house', 'rock'].includes(type)) {
          const img = document.createElement('img');
          if (type === 'source') img.src = 'img/spout.png';
          if (type === 'house') img.src = 'img/house.png';
          if (type === 'rock') {
            const rockImg = Math.random() < 0.5 ? 'rock.png' : 'gray-rock.png';
            img.src = `img/${rockImg}`;
          }
          tile.appendChild(img);
        }

        if (isRotatable) {
          tile.addEventListener('click', () => {
            rotateTile(tile);
            checkWin();
          });
        }

        tiles.push(tile);
        grid.appendChild(tile);
      });
    }

    function highlightPath(pathTiles) {
  tiles.forEach((tile, i) => {
    const type = tile.dataset.type;
    if (!['pipe', 'corner', 'tcross', 'cross'].includes(type)) return;
    const img = tile.querySelector('img');
    if (!img) return;

    const isInPath = pathTiles.has(i);
    const yellowSrc = getImageSrc(type, true);
    const normalSrc = getImageSrc(type, false);

    img.src = isInPath ? normalSrc : yellowSrc;
  });
}

    function checkWin() {
  const sourceIndex = tiles.findIndex(t => t.dataset.type === 'source');
  if (sourceIndex === -1) return;

  const visited = new Set();
  const queue = [sourceIndex];
  const pathTiles = new Set();

  while (queue.length > 0) {
    const currentIndex = queue.shift();
    if (visited.has(currentIndex)) continue;
    visited.add(currentIndex);
    pathTiles.add(currentIndex);

    const tile = tiles[currentIndex];
    const type = tile.dataset.type;
    const rotation = tile.dataset.rotation || 0;
    const x = currentIndex % SIZE;
    const y = Math.floor(currentIndex / SIZE);
    const conns = getConnections(type, rotation);

    for (const dir of conns) {
      const [dx, dy] = directions[dir];
      const [nx, ny] = [x + dx, y + dy];

      if (!isValidCoord(nx, ny)) continue;

      const neighborIndex = posToIndex(nx, ny);
      const neighbor = tiles[neighborIndex];
      if (neighbor.dataset.type === 'rock') continue;

      const neighborConns = getConnections(neighbor.dataset.type, neighbor.dataset.rotation || 0);
      if (neighborConns.includes(getOpposite(dir))) {
        if (neighbor.dataset.type === 'house') {
          pathTiles.add(neighborIndex);
          highlightPath(pathTiles);
          triggerWin();
          return;
        }
        queue.push(neighborIndex);
      }
    }
  }

  // Even if no win, still update highlight
  highlightPath(pathTiles);
}

    function triggerWin() {
      if (gameWon) return;
      gameWon = true;
      clearInterval(interval);
      starsEl.textContent = "üéâ YOU WIN!";
      alert("You connected the pipes! Great job!");
    }

    buildGrid();

    interval = setInterval(() => {
      if (gameWon) return;
      timer--;
      timerEl.textContent = timer;
      checkWin();
      if (timer <= 0) {
        clearInterval(interval);
        alert("‚è±Ô∏è Time's up! Try again!");
      }
    }, 1000);
  </script>
</body>
</html>
